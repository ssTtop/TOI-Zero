# สารบัญ



# Application for Coding

## CodeBlocks

CodeBlocks เป็น IDEs(Integrated Development Environments) หรือก็คือเป็นแอพที่มีเครื่องมือพร้อมสำหรับการเขียนโปรแกรม ซึ่ง CodeBlocks รองรับภาษา C / C++
จึงได้มีการนำมาใช้ในการสอบท้ายค่าย(สอวน)เพื่อคัดเลือกนักเรียน ในหลายๆศูนย์ ทางเราจึงอยากให้คุ้นชินกับ CodeBlocks ไว้ ซึ่งมีวิธีการโหลดและใช้งาน ดังนี้

### 1. ดาวโหลด
เข้าไปโหลดที่ <a href="https://sourceforge.net/projects/codeblocks/files/Binaries/25.03/Windows/codeblocks-25.03mingw-setup.exe/download" target="_blank">Dowload CodeBlocks</a> พอเข้าไปก็จะขึ้นหน้านี้มา 
<br><br>
<img src="https://github.com/user-attachments/assets/cf5f15db-cd6f-4b96-985f-a3bd0d5d7e9c" width="800px" align="center">
<br><br>

ทำการกดดาวโหลดตรงปุ่มสีเขียวๆ ให้เรียบร้อย
<br><br>

### 2. Set Up

เมื่อกดเข้าไปที่แอพจะพบหน้าต่างประมาณนี้

<img src="https://github.com/user-attachments/assets/97ecce9b-72fd-4dc5-976d-5783850537f3" width="800px" align="center">
<br><br>

- กดปุ่ม Creat a new project
- เลือก Console application
- กดสร้างให้เรียบร้อย (ไม่ต้องเลือกอะไรเพิ่มเติมให้เป็น default ให้หมด)

<br>

โปรแกรมจะขึ้นหน้านี้มา

<img src="https://github.com/user-attachments/assets/28b4b96e-8583-4d1b-8db3-3196c1ce3771" width="800px" align="center">
<br><br>

- จะเห็นแถบตรงด้านซ้ายมือให้กดคำว่า `Sources`

- และคลิกตรงไฟล์ที่เราตั้งชื่อไว้

<br>
<img src="https://github.com/user-attachments/assets/65182602-6b39-41e9-b30a-8e8e5e1826d5" width="800px" align="center">

<br><br>
ถ้าได้หน้าตาประมาณนี้แสดงว่าเสร็จสิ้นเรียบร้อยสามารถเขียนโค้ดได้แล้ว!!


### 3. วิธีการใช้งาน

จะมีปุ่มที่สำคัญๆ อยู่ไม่กี่ตัว

<img src="https://github.com/user-attachments/assets/862be86e-a7db-4bba-9145-72781bb05c90" width="800px" align="center">
<br><br>

- ตัวแรก(Build) คือการตรวจเช็คโค้ดให้เราว่าเขียนถูกตามภาษาไหม
- ตัวตรงกลาง(Run) คือการรันโปรแกรมตามที่เรา(Build) ล่าสุด แล้วจะมีหน้าจอแสดง Output ออกมา
- ตัวขวาสุด(Build and Run) คือการทำงานทั้งสองตัวเมื่อกี้พร้อมกันเลย(แนะนำให้ใช้ปุ่มนี้ไปเลย)

`หมายเหตุ` ถ้าเรากดปุ่มตัวซ้ายหรือตัวขวา โปรแกรมจะทำการ `save` โดยอัตโนมัติ

<br>

# ข้อควรรู้ก่อนเข้าสู่เนื้อหา

### - การเขียนตัวเลขในรูปสัญกรณ์อี

   การเขียนโปรแกรมส่วนใหญ่ไม่สามารถนำเสนอตัวเลขให้อยู่ในรูปแบบ a × $10^b$ จึงมีการใช้สัญกรณ์อักษรอีแสดงผลแทน 
   โดยใช้ `E` หรือ `e` (มาจาก exponent ที่แปลว่าเลขชี้กำลัง) และเขียนเลขยกกำลังตามหลังตัวอี 

   | ตัวเลข | เขียนในรูปสัญกรณ์อี |
   |:---:|:---:|
   | 5 × $10^8$ | 5e8|
   | 7.89 × $10^6$ | 7.89e6 |
   | -12,789,000,000 | -1.2789e10 |
   | 0.000002 | 2e-6 |
   | 0.00000012345 | 1.2345e-7 |

 

### - ส่วนประกอบที่ให้โค้ดเราทำงานได้

      1. #include <iostream>
      
      2. using namespace std;
      
      3. int main() {
      4.     cout<<"Hello World";
      5.     return 0;
      6. }

ตัว compiler(โปรแกรมที่อ่านโค้ดเรา) จะอ่านโค้ดของเราจากบนลงล่าง และจากซ้ายไปขวา

- บรรทัดที่ 1 เป็นการ import library เปรียบเสมือนการติดตั้งอาวุธ เพื่อให้เราสามารถใช้คำสั่งต่างๆใน library นั้นได้ ซึ่งจะมี libraryโกงๆ อยู่ตัวนึงคือ #include <bits/stdc++.h> มีตัวนี้เหมือนมีอาวุธครบมือ เกือบจะใช้คำสั่งได้แทบทุกอย่าง

- บรรทัดที่ 2 ทำให้เราเขียนโค้ดสั้นลง จากปกติเวลาจะใช้คำสั่งเราต้องพิมพ์ std::cout<<"Hello World"; แต่ถ้ามีบรรทัดนี้ก็เขียนแค่ cout<<"Hello World";

- บรรทัดที่ 3-6 เป็นฟังก์ชันหลักที่ตัวโปรแกรมจะเรียกใช้งานคำสั่งในนี้ 

- บรรทัดที่ 4 คือ คำสั่งต่างๆที่เราต้องการ เขียนไว้ในนี้ เช่นในตัวอย่าง สั่งให้ Output คำว่า "Hello World"

- บรรทัดที่ 5 คือ เอาไว้ส่งค่ากลับของฟังก์ชันนั้นๆ และยังสามารถสั่งให้หยุดการทำงานได้ ซึ่งจะพูดถึงอีกที่ในหัวข้อเรื่องฟังก์ชัน ในที่นี้(ฟังก์ชัน main) จะมีหรือไม่มีบรรทัดนี้ตัวโปรแกรมก็สามารถทำงานได้

<br>

### - Comment
   การคอมเมนต์ คือส่วนที่เราเขียนลงไปแล้ว โปรแกรมจะไม่อ่านในส่วนนั้น ซึ่งสามารถเขียนได้อยู่ 2 แบบหลักๆ

   การคอมเมนต์บรรทัดเดียว
      
      // this is comment

   การคอมเมนต์หลายบรรทัด
      
      /*
      eieieiei
      อุอิอิอา อุอิอิอา
      ทุงๆๆๆๆๆๆๆๆ ซาฮู่ร์
      */

   มีประโยชน์คือ โปรแกรมจะไม่อ่านโค้ดในส่วนที่คอมเมนต์ไว้ ทำให้สามารถใช้คอมเมนต์เพื่ออธิบายการทำงานของโปรแกรมเราได้

<br>

# Variable


| ตัวแปร | รับค่า | Bytes |
|:---:|:---:|:---:|
| int | จำนวนเต็ม -2,147,483,647 ถึง 2,147,483,647 | 4 |
| short int | จำนวนเต็ม -32,768 ถึง 32,767 | 2 |
| long long | จำนวนเต็ม -9,223,372,036,854,775,808 ถึง 9,223,372,036,854,775,807 | 8 |
| unsigned long long | จำนวนเต็ม 	0 ถึง 18,446,744,073,709,551,615 | 8 |
| float | ทศนิยม 3.4e-38 ถึง 3.4e38 | 4 |
| double | ทศนิยม 1.7e-308 ถึง 1.7e308  | 8 |
| bool | true/false | 1 |
| char | เอาไว้เก็บตัวอักษรเป็น [ascii](https://github.com/Warmhugboi/RoadToPosn1/blob/main/README.md#ascii-code) | 1 |
| string | เก็บเป็นข้อความยาวๆ เหมือนเป็น char หลายตัว | 1 * (ขนาดของ string) |

`เพิ่มเติม` unsigned คือเลขจำนวนเต็มที่ไม่ใช่ลบ (ตั้งแต่ 0 ขึ้นไป)

วิธีประกาศชื่อตัวแปร

      ประเภทตัวแปร ชื่อตัวแปร;       // ชื่อตัวแปรระวังอย่าให้เหมือนชื่อฟังก์ชัน หรือชื่อเฉพาะ
      int a;
      string s;
      char c;

ซึ่งเราสามารถกำหนดค่ามันได้ด้วย (คำเตือน!! ถ้าไม่กำหนดค่าไว้มันจะเป็นค่ามั่วๆ ก่อนนำไปใช้ดูให้ดี)

      int a = 10000;      
      float b = 1.243;
      bool c = true;        // ในที่นี้ สามารใช้ 1/0 แทน true/false
      char d = 'A'       // ต้องใช้ '' เท่านั้น 
      string s = "Apple"        // ต้องใช้ "" เท่านั้น

<br>

# Input/Output

### __${\color{green}-}$__ **${\color{green}cin}$**

เป็นคำสั่งเอาไว้รับค่า ซึ่งก่อนจะรับค่าอย่าลืมประกาศตัวแปรไว้ก่อนด้วย

      int n;
      cin >> n;

สามารถรับหลายๆตัวพร้อมกันได้ ซึ่งการรับแต่ละตัวจะแยกกันด้วย ช่องว่าง หรือการขึ้นบรรทัดใหม่ก็ได้

      int n,m,s,t;
      string x;
      cin >> n >> m >> s >> t >> x ;


### __${\color{green}-}$__ __${\color{green}cout}$__

เป็นคำสั่งเอาไว้พิมพ์ค่าแสดงออกทางหน้าจอ

      int n,m,s,t;
      string x;
      cin >> n >> m >> s >> t >> x ;
      cout << n << ' ' << m ;

ซึ่งในภาษา c++ จะมีการสั่งพิมพ์ที่เรียกว่า Escape Sequences 

| Escape Sequences | หน้าที่ |
|:---:|:---:|
| \n | ขึ้นบรรทัดใหม่ |
|endl| ขึ้นบรรทัดใหม่เหมือนกัน แต่กาก|

ตัวที่ใช้หลักๆ มีแค่ตัวนี้ แต่ถ้าอยากลองเล่นตัวอื่นๆดู ก็ศึกษาเพิ่มเติมได้

ซึ่งเราสามารถใช้ `\n` เพื่อบังคับขึ้นบรรทัดใหม่ เพื่อให้พิมพ์ตามรูปแบบที่โจทย์ต้องการได้

      int n = 10, m = 15;
      cout << n << "\n" << m ;

วิธีการแสดงแสดงค่าออกมาเป็น `ทศนิยม`

      float n = 5.13;
      cout << fixed << setprecision(x) << n;    // x คือ จำนวนตำแหน่งของทศนิยม

### - ตำราลับ (ของดี)

ใน C++ มีสูตรลับในการทำให้โปรแกรมเรารันเร็วขึ้นมากๆ โดยใช้คำสั่ง `2` ตัวนี้ `ios_base::sync_with_stdio(false)` กับ `cin.tie(0)`

        #include <bits/stdc++.h>
        using namespace std;
        
        int main() {
            ios_base::sync_with_stdio(false);    // ทำการปิดการซิงค์กับ stdio ของ C (เช่น scanf, printf)
            cin.tie(0);     // ยกเลิกการเชื่อมกันของ cin/cout โดยจะทำการ cout ทีเดียวหลังจากทำการ cin ทั้งหมดแล้ว

            // หรือ
            cin.tie(nullptr)->sync_with_stdio(false);       // มีความหมายเดียวกับ 2 บรรทัดข้างบน
            
            // process
            
       }

`!!trick` เพิ่มเติม ถ้าอยากรับ string ที่มีช่องว่างให้ใช้ `getline()` เช่น

    string s;
    getline(cin, s);     // Ex.Input = I am so handsome
    cout << s ;        // Output = I am so handsome
    
จากตัวอย่าง เราก็จะเก็บ string ที่มีช่องว่างได้ และถ้ามี `cin` ก่อนหน้า `getline()` ให้ใช้คำสั่ง `cin.ignore()` เช่น

    string a,b,s;
    
    cin >> a >> b;
    cin.ignore();      // ลองรันโปรแกรมแบบมีบรรทัดนี้และไม่มีดู จะเห็นถึงความแตกต่าง
    getline(cin, s);
    cout << s;

<br>

# Conditions and If Statements

### - ตัวดำเนินการทางตรรกศาตร์

| ตัวดำเนินการ | ชื่อ | คำอธิบาย |
|:---:|:---:|:---:|
| `&&` | and | เป็นจริงก็ต่อเมื่อเป็นจริงทั้งคู่ |
| <code>\|\|</code> | or | เป็นจริงก็ต่อเมื่อมีตัวใดตัวหนึ่งเป็นจริง |
| `!` | not | จะกลับค่าความจริงเป็นค่าตรงข้าม |

เราสามารถใช้ `&& / and` ทดแทนกันได้ รวมถึงตัวอื่นๆด้วย


### - การเปรียบเทียบ

| Condition | ความหมาย |
|:---:|:---:|
| a < b| a มีค่าน้อยกว่า b หรือไม่ |
| a <= b| a มีค่าน้อยกว่าหรือเท่ากับ b หรือไม่ |
| a > b| a มีค่ามากกว่า b หรือไม่ |
| a >= b| a มีค่ามากกว่าหรือเท่ากับ b หรือไม่ |
| a == b| a มีค่าเท่ากับ b หรือไม่ |
| a != b| a มีค่าไม่เท่ากับ b หรือไม่ |

เมื่อทำการเปรียบเทียบ ถ้าเป็นจริงจะได้ค่าเป็น `true` ถ้าไม่จริงจะได้ค่าเป็น `false`

### - if / else if / else

โครงสร้าง `if` มีดังนี้

      if(condition){
         //process
      }

ถ้า `condition` เป็นจริงให้ทำคำสั่งใน `if` เช่น

      int a = 10, b = 20;
      if(a < b){
         cout << "a is greater than b";
      }

นอกจาก `if` แล้วยังมีอันอื่นอีก ได้แก่

- __${\color{red}if}$__ ไว้ใช้เป็นเงื่อนไขแรก
- __${\color{red}else}$__ __${\color{red}if}$__ ไว้ใช้เป็นเงื่อนไขถัดๆมา ถ้าตัวก่อนหน้าไม่เป็นจริง
- __${\color{red}else}$__ ไว้ใช้เป็นเงื่อนไขนอกเหนือจากตัวทั้งหมดก่อนหน้า

ตัวอย่างเช่น 

      int a = 10, b = 20;
      if(a > b){
         cout << "a is greater than b";
      }
      else if(a < b){
         cout << "a is lees than b";
      }
      else {
         cout << "a is equal to b";
      }

<br>

# Math in C++

| ตัวกำเนินการ | ความหมาย |
|:---:|:---:|
| a+b | เอา a มาบวกกับ b |
| a-b | เอา a มาลบด้วย b |
| a*b | เอา a มาคูณกับ b |
| a/b | เอา a มาหารด้วย b |
| a%b | เศษเหลือจากการหาร a ด้วย b |
| aeb | a * $10^b$ |

ตัวอย่างการใช้งาน

      int a = 10;
      a = a + 2 ;   // หมายถึงให้ a บวกค่าเพิ่มเข้าไป 2
      cout << a;  // Output = 12
      a = a * 4 ;   // หมายถึงให้ a คูณกับ 4  
      cout << a;  // Output = 48

วิธีเขียนแบบลัดๆ

      int a = 10;
      a += 2 ;     // ย่อมากจาก  a = a + 2
      a *= 4 ;     // ย่อมาจาก  a = a * 4

และวิธีการเขียนลัดๆ อีกแบบ (ใช้ได้เฉพาะบวกหรือลบเท่านั้น)

      int a = 5;
      a++ ;   // ย่อมาจาก a = a + 1
      ++a ;   // ย่อมาจาก a = a + 1
      a-- ;   // ย่อมาจาก a = a - 1
      --a ;   // ย่อมาจาก a = a - 1

ความแตกต่างระหว่าง `a++/++a` คือถ้าเป็น `++a` จะทำการบวกค่า a ก่อนแล้วค่อยเอาไปใช้ แต่ถ้าเป็น `a++` จะนำค่าไปใช้ก่อนแล้วค่อยบวกค่า a เช่น

ถ้าเป็น a++/a--
      
      int a = 10 ;
      cout << a++ << "\n";    // Output = 10
      cout << a ;      // Output = 11

ถ้าเป็น ++a/--a

      int a = 10 ;
      cout << ++a << "\n";    // Output = 11
      cout << a ;      // Output = 11


### - ฟังก์ชันที่เกี่ยวกับ math

| ฟังก์ชัน | ค่าที่ได้ |
|:---:|:---:|
| abs(x) | ถ้า x < 0 จะได้ -x นอกนั้นได้ค่า x |
| sqrt(x) | $\sqrt{x}$ |
| pow(a,b) | $a^b$ |
| __gcd(a,b) | ห.ร.ม.ของ a กับ b |

ในการหา lcd หรือ ค.ร.น. ของ a กับ b จะไม่มีฟังก์ชันสำเร็จรูปให้ แต่มีวิธีการหาจากหลักคณิตศาสตร์ คือ

จาก `a*b = lcd*gcd` 

ดังนั้น `lcd = (a*b)/gcd`

<br>

# Loop

### __${\color{blue}for}$__

ในภาษา C++ มีการเขียน for loop หน้าตาดังนี้

    int n = 10;
    for(int i = 0 ; i < n ; ++i){
        //process
    }

หลักการทำงานคือ

- `int i = 0` คือตั้งต้นให้ i = 0
- `i < n` คือ ถ้า i < n อยู่ให้ทำงานต่อ ถ้า i>=n จะหยุดการทำงาน
- `++i` คือ ค่า i จะบวก 1 เมื่อจบการทำงานใน process


### __${\color{blue}while}$__


ใน C++ มีการเขียน while loop หน้าตาดังนี้

    while(condition){
        //process
    }

ถ้า `condition` เป็น `true` จะทำงานใน process ไปเรื่อยๆ จนกว่าจะเป็น `false` เช่น

    int n = 10 ;
    while(n--){
        //process
    }

จากตัวอย่าง โปรแกรมจะทำงานไปเรื่อยๆ จนกว่า `n==0` แล้วจึงหยุดทำงาน เนื่องจาก `0` ในค่าความจริงคือ `false`

### - Break / Continue

ทั้งใน `for` และ `while` ถ้าเราต้องการสั่งให้หยุดการวนลูป เราจะใช้คำสั่ง `break` ไว้ใน `loop` เช่น

    for(int i = 0 ; i < 10 ; ++i){
        if(i==5){
            break;       // ถ้า i==5 จะหยุดการวนลูป
        }
        cout << i << ' ' ;
    }

    // Output = 1 2 3 4

และยังมีคำสั่ง `continue` ที่เอาไว้ใช้ในตอนที่อยากข้ามไปลำดับถัดไป เช่น

    for(int i = 0 ; i < 10 ; ++i){
        if(i%2 == 0){
            continue;       // ถ้า i เป็นเลขคู่ให้ข้ามไปลำดับถัดไป
        }
        cout << i << ' ' ;
    }
    
    // Output = 1 3 5 7 9

# Array

`array` เป็น Data Struct อย่างนึงที่สามารถเก็บข้อมูลได้หลายๆตัว มีวิธีประกาศดังนี้

    <variables> name[size] ;
    // เช่น
    int arr[5];

    และเรายังสามารถประกาศค่าเริ่มต้นให้มันเลยได้

    int arr[5] = {1,6,3,4,9};
    
    // หรือ 
    
    int arr[] = {1,6,3,4,9};      // ซึ่งวิธีหาจำนวนสมาชิกคือ `sizeof(arr)/sizeof(arr[0])`   
    
    // หรือประกาศสมาชิกอีกแบบ 
    
    int arr[5];
    arr[0] = 1 ;
    arr[1] = 6 ;
    arr[2] = 3 ;
    arr[3] = 4 ;
    arr[4] = 9 ;

ซึ่งถ้าเราอยากเข้าถึงค่าในแต่ละตำแหน่ง เราต้องมาทำความรู้จักกับ `index` ซึ่งมันก็คือการบอกตำแหน่ง โดยเริ่มจาก `index` ที่ `0,1,2,3,...,n-1` โดยที่ `n` คือจำนวนข้อมูลใน `array`

จากตัวอย่างเมื่อกี้

| index | ค่าของ index | การเข้าถึง |
|:---:|:---:|:---:|
| 0 | 1 | arr[0] |
| 1 | 6 | arr[1] |
| 2 | 3 | arr[2] |
| 3 | 4 | arr[3] |
| 4 | 9 | arr[4] |

ตัวอย่างการรับค่าข้อมูลไปเก็บใน `array` และ แสดงผลออกมา

    int n;
    cin >> n;       // ต้องการรับค่ากี่ตัว
    int arr[n] ;
    
    // รับค่า
    for(int i = 0 ; i < n ; ++i){
        int x;
        cin >> x;       // รับค่าเข้ามา
        arr[i] = x;     // กำหนดค่า
    }
    
    // (วิธี 2) รับค่าแบบรวบรัด
    for(int i = 0 ; i < n ; ++i){
        cin >> arr[i]
    }

    // (วิธี 3) รับค่าแบบรัดในรวบรัด
    for(auto&i:arr)        
        cin >> i ;
        
    /*  auto& คือการเข้าถึงสมาชิกทุกตัวใน array ตั้งแต่ index 0,1,2,...,n-1 โดยสร้างตัวแปร i มารองรับ (ปล1.ถ้าไม่ใส่ & จะทำให้ตัวแปร i เหมือนเป็นแค่ตัวก็อปปี้เมื่อเรา cin ใส่ค่าก็อปปี้ ทำให้สมาชิก
        ใน array ไม่เปลี่ยนแปลง อารมณ์แบบ & ทำหน้าที่เข้าถึงที่อยู่ของสมาชิกใน array โดยตรงเลย) (ปล2.ถ้างงๆ ก็ไม่เป็นไรหรอกใช้ auto& ไปเลย ของโกง)  
    */
    
    // แสดงค่าออกมา
    for(int i = 0 ; i < n ; ++i){
        cout << arr[i] << " ";
    }


ซึ่งเราสามารถประกาศ `array` ให้กลายเป็น `2` มิติได้

    int arr[2][3] = {{1,2,3},{4,5,6}}
            
    // มีความหมายว่าให้ array มีขนาด 2 ช่อง แต่ละช่องมี array ขนาด 3 ช่อง

วิธีเข้าถึงตำแหน่งก็จะใช้ `[][]` 

    int arr[3][3];

    // รับค่า
    for(int i = 0 ; i < 3 ; ++i){
        for(int j = 0 ; j < 3 ; ++j){
            cin >> arr[i][j];
        }
    }

    // แสดงค่า
    for(int i = 0 ; i < 3 ; ++i){
        for(int j = 0 ; j < 3 ; ++j){
            cout << arr[i][j] << ' ' ;
        }
        cout << "\n"; 
    }

`คำเตือน!!` ห้ามใช้ `index` ติดลบ หรือ เกินขอบเขตที่เราประกาศไว้ ระวังโค้ดระเบิดตู้มต้าม

<br>

# Vector

`vector` มีหน้าที่เหมือนกับ `array` เลย คือ ทำหน้าที่เก็บข้อมูลหลายๆตัว แต่จะแตกต่างตรงที่ `array` ไม่สามารถเปลี่ยนขนาดได้ ซึ่ง `vector` จะเข้ามาแก้ปัญหาในส่วนนี้
มีการประกาศตัวแปรดังนี้

    vector<<variable>>name ;
    
    // เช่น
    vector<int>vec ;

วิธีประกาศค่า

    vector<int> vec = {1, 2, 3...};    // ได้เรื่อยๆ ไม่มีจำกัด
    
    // หรือ
    int n = 10 ;
    vector<int> vec(n, 0);      // กำหนดให้ตั้งแต่ index ที่ 0 ถึง n - 1 เป็นค่า 0

### - คำสั่งใน Vector

| Function | คำอธิบาย | Time Complexity |
|:---:|:---:|:---:|
| .push_back(x) | ใส่ค่า x ต่อหลังเข้าไปใน vector | O(1) |
| vec[i] / .at(i) | เข้าถึงค่าของ index ตำแหน่งที่ i | O(1) |
| .size() | ได้ค่าจำนวนสมาชิกของ vector ในเวลานั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน vector | O(n) |
| .front() | เข้าถึงสมาชิกตัวหน้าสุดของ vector | O(1) |
| .back() | เข้าถึงสมาชิกตัวหลังสุดของ vector | O(1) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน vector นอกนั้นได้ค่า 0 | O(1) |
| .pop_back() | ลบค่าตัวข้างหลังสุด | O(1) |
| .begin() | เข้าถึงสมาชิกตัวหน้าสุดของ vector แต่เป็น iterator | O(1) |
| .end() | เข้าถึงสมาชิกตัวหลังสุดของ vector แต่เป็น iterator | O(1) |
| .erase() | ลบค่าตรงที่ค่าในวงเล็บชี้อยู่ โดยค่าในวงเล็บต้องเป็น iterator | O(n) |

<br>

# Ascii Code

อย่างที่เราเรียนมาในหัวข้อ [Variables](https://github.com/Warmhugboi/RoadToPosn1/blob/main/README.md#variable) ว่า char เป็นตัวแปรที่ทำหน้าที่รับตัวอักษรตัวเดียว \
ซึ่งตัวอักษรตัวใดๆ จะมีค่า 2 แบบ คือ `ตัวมันเอง` กับ `ค่าของมัน(ascii code)` เช่น

    char c = 'A';

ในที่นี้ตัวมันเองคือ `A` แต่ค่าของมันคือ `65` แล้วเราจะรู้ได้อย่างไรว่าตัวอักษรแต่ละตัวมีค่า `ascii code` เท่าไหร่ วิธีมีดังนี้

    char c = 'A'; 
    cout << c << '\n' ;     // Output = A   ซึ่งก็คือตัวมันเอง
    cout << int(c) ;      // Output = 65  ซึ่งก็คือค่า ascii ของมันนั่นเอง 

    // เราสามารถเก็บค่า ascii code ในตัวแปร char แทนได้ เช่น
    char c = 65 ;        // c = 'A'
    

ในทางกลับกันถ้าเรามีค่า `ascii code` อยู่แล้ว แล้วเราอยากรู้ว่ามันคือตัวอักษรอะไรล่ะ ก็มีวิธีการดังนี้

    int x = 65 ;
    cout << char(x);       // Output = A  ก็จะได้ออกมาเป็นตัวอักษรที่มีค่า ascii = 65 นั่นเอง

`เตือน!!` แน่นอนว่าค่า `ascii` ของตัวพิมพ์ใหญ่กับตัวพิมพ์เล็กไม่เท่ากัน รวมถึงตัวเลขแต่ละตัว(0-9) ก็มีค่า `ascii` ของตัวมันเองนะ

<img src="https://www.asc.ohio-state.edu/demarneffe.1/LING5050/material/ASCII-Table.png" width="700px" align="center">
ขอบคุณภาพจาก https://www.asc.ohio-state.edu/demarneffe.1/LING5050/material/characters.html

<br>

# String

`string` คือโครงสร้างข้อมูลที่ใช้เก็บข้อความ ซึ่งหากมองลึกๆถึงตัวสตริงแล้วมันคือ `vector` ที่ข้างในประกอบไปด้วย `char` เพราะสามารถทำ operation ต่างๆที่ vector สามารถทำได้ ไม่ว่าจะเป็นการเข้าถึงตำแหน่งที่ i-th การเปลี่ยนค่า ณ ตำแหน่งหนึ่ง การถามขนาด หรือแม้แต่การนำค่าไปต่อหลัง แหละนำค่าออกจากด้านหลังของ string 
มีการประกาศตัวแปรดังนี้

    string<<variable>>name ;
    
    // เช่น
    string<int> st ;

วิธีประกาศค่า

    string<int> st = "ILoveTNTGradering.com";    // ได้เรื่อยๆ ไม่มีจำกัด
    
    // หรือ
    int n = 10 ;
    string<int> st(n, 'D');      // กำหนดให้ตั้งแต่ index ที่ 0 ถึง n - 1 เป็น 'D'

| Function | คำอธิบาย | Time Complexity |
|:---:|:---:|:---:|
| .push_back(x) | ใส่ค่า x ต่อหลังเข้าไปใน string | O(1) |
| st[i] / .at(i) | เข้าถึงค่าของ index ตำแหน่งที่ i | O(1) |
| .size() / .length() | ได้ค่าจำนวนสมาชิกของ string ในเวลานั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน string | O(n) |
| .front() | เข้าถึงสมาชิกตัวหน้าสุดของ string | O(1) |
| .back() | เข้าถึงสมาชิกตัวหลังสุดของ string | O(1) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน string นอกนั้นได้ค่า 0 | O(1) |
| .pop_back() | ลบค่าตัวข้างหลังสุด | O(1) |
| .begin() | เข้าถึงสมาชิกตัวหน้าสุดของ string แต่เป็น iterator | O(1) |
| .end() | เข้าถึงสมาชิกตัวหลังสุดของ string แต่เป็น iterator | O(1) |
| .erase() | ลบค่าตรงที่ค่าในวงเล็บชี้อยู่ โดยค่าในวงเล็บต้องเป็น iterator | O(n) |
| .substr(start,steps) | การหา substring หรือ string ย่อย โดยที่ start คือตำแหน่งเริ่มต้นของ substring ที่เราอยากได้ โดยที่ตำแหน่งเป็น index และ steps คือเราต้องการ substring ที่มีความยาวเท่าไหร่ (เริ่มที่ start นับไปอีก steps ตัว) | O(n) |

นอกจากนี้ string ยังมีการดำเนินการพิเศษเป็นของตัวเอง ที่ vector ไม่มีอีกด้วย เช่นการนำสตริงมาต่อหลังกัน หรือการนำ char มาต่อหลัง เช่น

      string a = "IloveTNT";
      string b="Gradering";
      char c='.';
      string d="com";
      a += b;  // IloveTNTGradering
      a += c;  // IloveTNTGradering.
      a += d;  // IloveTNTGradering.com
      if (a == "IloveTNTGradering.com"){
            cout << "The Goat.";
      }


<br>

# Set

`set` ใน C++ จะมีนิยามเหมือนกับ เซตในคณิตศาสตร์เลย คือ ไม่มีสมาชิกที่ซั้ากัน และ เรียงจากน้อยไปมาก\
มีวิธีการประกาศ ดังนี้

    set<<variable>> name ;
      
    //เช่น
    
    //แบบไม่ประกาศค่า
    set<int> st ; 
    
    //แบบประกาศค่า
    set<int> st = {0,1,0,2,0,6,9,3,5,2} ;     // สมาชิกใน st = {0,1,2,3,5,6,9}
    
สำหรับ `set` เราไม่สามารถเข้าถึงตำแหน่งแบบ `array` หรือ `vector` ได้แต่เราจะนำไปใช้งานแบบอื่นจากคุณสมบัติของมัน

### - คำสั่งใน Set 

ใน `time complexity` จะมีค่าคงที่ C เพิ่มขึ้นมานิดหน่อยบางตัว

| Function | คำอธิบาย | Time Complexity |
|:---:|:---:|:---:|
| .insert(x) | เป็นการใส่ค่า x เข้าไปใน set โดยจะเรียงให้เรียบร้อบ | O(log(n) + C) |
| .size() | เราจะได้ค่าของจำนวนสมาชิกใน set ในตอนนั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน set | O(n) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน set นอกนั้นได้ค่า 0 | O(1) |
| .begin() | เข้าถึงสมาชิกตัวหน้าสุดของ set แต่เป็น iterator | O(1) |
| .end() | เข้าถึงสมาชิกตัวหลังสุดของ set แต่เป็น iterator | O(1) |
| .erase() | ลบค่าตรงที่ค่าในวงเล็บชี้อยู่ โดยค่าในวงเล็บต้องเป็น iterator | O(logn + C) |
| .find() | หาค่าใน set ว่าอยู่ตำแหน่งใด | O(log(n)) |


### - Set แบบอื่นๆ

- `unordered_set` ไม่มีสมาชิกซํ้ากัน และไม่เรียง

- `multiset` ทีสมาชิกซํ้ากัน และเรียงจากน้อยไปมาก

- `unordered_multiset` มีสมาชิกซํ้ากัน และไม่เรียง

และ เรายังสามารถประกาศแบบ `set<<variable>,greater<variable>> name ;` เพื่อให้เรียงจากมากไปน้อยได้

<br>

# Function

ฟังก์ชันคือ กลุ่มของโค้ดที่เมื่อเราเรียกใช้งานก็จะทำงานคำสั่งภายในฟังก์ชันนั้น ซึ่งช่วยให้เราเขียนโค้ดได้สะอาดมากขึ้น โดยเราจะมีการเขียนไว้ข้างบน `main`\
โดยฟังก์ชันจะมีอยู่ 2 แบบหลักๆ คือ `ส่งค่ากลับ` และ `ไม่ส่งค่ากลับ(void)` 

### - แบบส่งค่ากลับ

        #include <bits/stdc++.h>
        using namespace std;

        <variable> <name>(parameter_type parameter_name, ...){
              // process
              // return
        }

        // เช่น
        int summation(int x, int y)      // ค่าใน () เราเรียกว่า พารามิเตอร์ มีการประกาศในรูปแบบ <variable> <name> เช่น `int x` คั่นแต่ละพารามิเตอร์ด้วย `,` ซึ่งจะมีพารามิเตอร์กี่ตัวก็ได้(ไม่มีก็ได้) จะเป็นการรับค่ามาจากการเรียกใช้ใน main
        {
            int c = x+y ;
            return c ;          // การส่งค่ากลับไปยังที่ที่เราเรียกใช้
        }
        
        int main() {
            int a = 10 ;
            int b = 20 ;
            cout << summation(a,b);         // เรียกใช้ฟังก์ชันชื่อ `summation` และทำการส่งค่า a และ b เข้าไปเพื่อใช้งานต่อในฟังก์ชัน โดยมีจำนวนพารามิเตอร์เท่ากับที่ประกาศไว้
       }
       // Output = 30

จะเป็นฟังก์ชันที่เราเรียกใช้แล้วจะมีการ `ส่งค่ากลับมา(return)` ซึ่งเราจะใช้ `<variable>` ตามค่าที่เราส่งกลับ(return)

### - แบบไม่ส่งค่ากลับ(void)

        #include <bits/stdc++.h>
        using namespace std;

        void <name>(parameter_type parameter_name, ...){
              // process
        }

        // เช่น
        void eiei(){
            cout << "Hello World ";
            cout << "HAHAHA";
        }
        
        int main() {
            
            eiei();      // เรียกใช้งานฟังก์ชัน eiei     
       }
       
       // Output = Hello World HAHAHA

จะเห็นว่าไม่มีการ ส่งค่ากลับ(return) มีประโยชน์คือประหยัด `memory`

### - Recursive function

เป็นฟังก์ชันที่มีการเรียกใช้ตัวมันเอง ถ้าตัวอย่างที่เห็นภาพสุดก็ต้องเป็น `Fibonacci Number` นั่นคือ `0,1,1,2,3,5,8,13,21,34,...` จะเห็นว่าตำแหน่งใดๆ จะเกิดจากผลรวมของ 2 ตัวก่อนหน้ามัน 
โดยเรากำหนดให้ ลำดับที่ `0` มีค่าเท่ากับ `0` และ ลำดับที่ `1` มีค่าเท่ากับ `1` ซึ่งเราเรียกสองตัวนี้ว่า `base case` เนื่องจากลำดับที่ `0` ไม่มีตัวเลขก่อนหน้ามัน และ ลำดับที่ `1` ก็มีแค่ลำดับที่ `0`
อยู่ก่อนหน้ามันตัวเดียวนั่นเอง ส่วนวิธีการเขียนมีดังนี้

        #include <bits/stdc++.h>
        using namespace std;


        int fibo(int n){
            if(n==0)      // base case
                return 0;
            if(n==1)      // base case
                return 1;
            // วิธีที่ไม่แนะนำ  
            /*
            int value = fibo(n-1) + fibo(n-2);
            return value;
            เหตุผลเพราะในการ recur ของโค้ด โปรแกรมจะเรียกฟังชั่นไปเรื่อยๆจนถึง base-case 
            ซึ่งสังเกตุว่าก่อนถ้า int value จะถูกรีเทิร์นไป จะมีการเรียกฟังชั่นเดิมซ้ำ และสร้าง int value 
            เป็นเช่นนี้ซ้ำไปเรื่อยๆในกรณีที่เลวร้ายอาจทำให้ int value ถูกสร้างขึ้นมาเยอะมากๆ 
            จนทำให้ memory เกินขอบเขตที่รับไหว และทำให้ไม่ได้คะแนนในข้อนั้นๆ หรือ โปรแกรมแครชได้
            */
            
            // วิธีที่แนะนำ
            return fibo(n-1) + fibo(n-2);
        }
        
        int main() {
            ios_base::sync_with_stdio(false); 
            cin.tie(0);

            int n;
            cin >> n;
            cout << fibo(n);
            
        }

<br>

# Sort

ก็ตรงตัวเลย `sort` การจัดเรียง ซึ่งในที่นี้หมายถึง การเรียงข้อมูลจากน้อยไปมากหรือจากมากไปน้อย ซึ่งมันก็มีคำสั่งที่ใช้สำหรับการเรียงอยู่ คือ `sort()` 

วิธีใช้ `sort` กับ `array`

    // เรียงจากน้อยไปมาก
    
    int n = 5 ;          // สมมติมีข้อมูล 5 ตัว
    int arr[n] = {1,6,23,4,8};
    sort(arr, arr + n) ;      // sort จาก arr[0] ถึง arr[n-1]
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";     // Output: 1 4 6 8 23


    // เรียงจากมากไปน้อย

    int n = 5 ;          
    int arr[n] = {1,6,23,4,8};
    sort(arr, arr + n, greater<int>()) ;      
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";     // Output: 23 8 6 4 1
    
วิธีใช้ `sort` กับ `vector`

    // เรียงจากน้อยไปมาก
    
    vector<int> vec = {1,6,23,4,8};
    sort(vec.begin(), vec.end()) ;      // sort จากน้อยไปมาก
    for (int i = 0; i < vec.size() ; ++i)
        cout << arr[i] << " ";     // Output: 1 4 6 8 23


    // เรียงจากมากไปน้อย
          
    vector<int> vec = {1,6,23,4,8};
    sort(vec.begin(), vec.end(), greater<int>()) ;     //  sort จากมากไปน้อย 

    // หรือ 
    sort(vec.rbegin(), vec.rend())    // sort จากมากไปน้อยเหมือนกัน

    // แสดงค่า
    for (int i = 0; i < vec.size() ; ++i)
        cout << arr[i] << " ";     // Output: 23 8 6 4 1

`เกล็ดความรู็!!` เราสามารถใช้ `sort()` กับชุดข้อมูลที่เป็นตัวอักษรหรือข้อความได้ ซึ่งจะมีการเรียงตามค่า [Ascii](https://github.com/Warmhugboi/RoadToPosn1/blob/main/README.md#ascii-code) เลย เช่น

    // ถ้าเป็น char
    
    vector<char> vec = {'b', 'a', 'A', 'B', 'z'};
    sort(vec.begin(). vec.end());
    for (int i = 0; i < vec.size() ; ++i)
        cout << arr[i] << " ";     // Output: A B a b z     จะเห็นว่ามีการเรียงจากน้อยไปมากตามค่า Ascii

    // ถ้าเป็น string

    vector<char> vec = {"aaa", "aba", "abc", "bac", "aab"};
    sort(vec.begin(). vec.end());
    for (int i = 0; i < vec.size() ; ++i)
        cout << arr[i] << " ";     // Output: aaa aab aba abc bac     จะเห็นว่ามีการเรียงเหมือนหลักพจนานุกรมเลย 

<br>

# Binary Search

เรามาพูดถึงเรื่องการ `search` สมมติเรามีชุดข้อมูลแล้วหาว่าตัวที่เราต้องการอยู่ตำแหน่งไหน \
อย่างเช่น `0,2,5,7,8` ถามว่า `5` อยู่ที่ตำแหน่งที่เท่าไหร่ ก็คงต้องตอบว่า `index` ที่ `2` แล้วลองนึกดูว่าถ้าเรามีข้อมูลเป็นพันล้านตัว กว่าเราจะหาเจอหรือกว่าโปรแกรมจะหาเจอ คงใช้เวลาตู้มต้ามเลย
จึงมีแนวคิดเรื่อง `binary search` ขึ้นมา หลักการทำงานคือ แบ่งครึ่งชุดข้อมูลไปเรื่อยๆ แล้วดูว่าค่าตรงกลางมีค่ามากกว่าหรือน้อยกว่า ตัวที่เราอยากหา ถ้าเท่ากันเมื่อไหร่ก็แสดงว่าเจอแล้ว พูดไปคงจะงงไปดูตัวอย่างกัน

มีชุดข้อมูลจำนวน 10 ตัว `0,4,9,11,20,33,45,67,80,97` ต้องการหาว่า `33` อยู่ที่ตำแหน่งใด

|ครั้งที่ / index|0|1|2|3|4|5|6|7|8|9|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|0|4|9|11|`20`|33|45|67|80|97|
|2||||||33|45|`67`|80|97|
|3||||||33|`45`||||
|4||||||`33`|||||

- ครั้งที่ 1 เริ่มการแบ่งครึ่งครั้งแรก `index กึ่งกลาง = (0+9)/2 = 4.5 ปัดลงเป็น 4` มีค่าเท่ากับ `20` ซึ่งน้อยกว่า `33` เราเลยไม่จำเป็นต้องพิจารณาตัวเลขก่อนหน้า `20` เนื่องจากมีค่าน้อยกว่า `33` อย่างแน่นอน เราจึงสามารถตัดตัวเลขฝั่งซ้ายรวมถึง `20` ออกไปได้เลย
- ครั้งที่ 2 ทำการแบ่งครึ่งข้อมูลที่เหลือ `index กึ่งกลาง = (5+9)/2 = 7` มีค่า `67` ซึ่งมากกว่า `33` เราเลยตัดฝั่งขวารวมถึงตัวมันเอง `67` ออก
- ครั้งที่ 3 ทำการแบ่งครึ่งข้อมูล `index กึ่งกลาง = (5+6)/2 = 5.5 ปัดลงเป็น 5` มีค่า `45` ซึ่งมากกว่า `33` เราเลยตัดฝั่งขวารวมถึงตัวมันเอง `45` ออก
- ครั้งที่ 4 จะเห็นว่าเหลือข้อมูลตัวเดียวแล้ว `index กึ่งกลาง = (5+5)/2 = 5` มีค่า `33` ซึ่งเท่ากับ ค่าที่เราต้องการหา ก็ถือว่าจบการทำงาน ก็จะได้ค่า index ตำแหน่งนี้มา

จากปกติเราใช้เวลา O(n) จะลดลงเหลือ O(log n)!!  

`คำเตือน!!` อย่าลืม `sort` ข้อมูลก่อนการ `binary search` ไม่งั้นจะทำงานไม่ถูกต้องนะจ้ะ

วิธีการเขียน `binary search`

        #include <bits/stdc++.h>
        using namespace std;

        int BinarySearch(int arr[], int n, int x){
            int l = 0;      // ตัวแรกสุด
            int r = n - 1;       // ตัวขวาสุด
            int mid;
            while(r >= l){
                mid = (l+r)/2;
                if(arr[mid] > x)
                    r = mid - 1;
                else if(arr[mid] < x)
                    l = mid + 1;
                else
                    return mid;
            }
        }
        int main() {
            ios_base::sync_with_stdio(false); 
            cin.tie(0);
            
            int n,x ;     
            cin >> n;    // จำนวนข้อมูล
            int arr[n];
            for(int i = 0 ; i < n ; ++i)
                cin >> arr[i];
            cin >> x;     // ตัวที่เราต้องการหา
            cout << BinarySearch(arr, n , x);
       }


# Range Sum Query - Prefix Sum (AKA. Quick Sum)

ในหัวข้อนี้ส่วนใหญ่จะเกี่ยวข้องกับโจทย์ที่มีการถามผลรวมตั้งแต่ `l` ถึง `r` หลายๆครั้ง ถ้าเราทำวิธี loop ตรงๆ จะทำให้เกิดการทำงานซํ้าซาก วิธีคือ\
สมมติเรามีตัวเลขทั้งหมด `n` ตัวเก็บไว้ในอาเรย์ชื่อ `arr` เราจะทำให้ `arr` ตำแหน่งที่ `i` เปล่ยนค่าเป็นผลรวมตั้งแต่ตัวแรกมาถึงตัวที่ `i` 
เมื่อโจทย์ถามผลรวมตัวที่ `l` ถึง `r` จะได้ว่าคำตอบเป็น `arr[r] - arr[l-1]` ซึ่งมีวิธีการเขียนดังนี้


        #include <bits/stdc++.h>
        using namespace std;

        int main() {
            ios_base::sync_with_stdio(false); 
            cin.tie(0);

            int n,q;
            cin >> n >> q;    // รับค่าจำนวนตัวเลข และ จำนวนคำถาม
            int arr[n];
            for(int i = 0 ; i < n ; ++i){
                cin >> arr[i];
                if(i!=0)               // ที่ต้อง i!=0 เนื่องจาก index จะติดลบเอาได้
                    arr[i] += arr[i-1]     // ค่าของ arr[i] จะมีค่าเท่ากับตัวมันเองบวกกับผลรวมสะสมตัวก่อนหน้า
            }
            for(int i = 0 ; i < q ; ++i){
                int l,r;
                cin >> l >> r;
                if(l!=0)
                    cout << arr[r] - arr[l-1] << '\n';
                else
                    cout << arr[r] << '\n';
            }
            
        }




    

